<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Music Room</title>
		<meta name="description" content="Music Room">
		<meta name="author" content="Sean O'Neil">
		<style>
        * {
    box-sizing: border-box;
}
		body {
			text-align: center;
			background-color: #000000;
			background-image: url('/synthwave.jpg');
			color: #FFFFFF;
			font-size: 20px;
		}
		h1 {
			margin-top: 5px;
			margin-bottom: 5px;
		}
		h3 {
			margin-top: 3px;
			margin-bottom: 3px;
		}
		h4 {
			margin-top: 2px;
			margin-bottom: 2px;
		}
		ol {
			margin-top: 3px;
			margin-bottom: 3px;
		}
		li {
			text-align: left;
		}
		.maintable {
			width: 100%;
			background-color: #000000C0;
		}
		input {
			background-color: #808080;
			color: #FFFFFF;
			font-size: 20px;
		}
		button {
			background-color: #404040;
			color: #FFFFFF;
			font-size: 1.3em;
		}
		.del, .toTop, .toBottom {
			font-size: 1.3em;
		}
		.up, .down {
			font-size: 1.3em;
		}
		.inactiveSong {
			font-size: 20px;
			font-weight: normal;
			font-style: normal;
		}
		.activeSong {
			font-size: 20px;
			font-style: italic;
			font-weight: normal;
		}
		.playingSong {
			font-size: 20px;
			font-style: italic;
			font-weight: bold;
		}
		.iframeWrapperSmall {
			display: inline-block;
			position: relative;
			vertical-align: top;
		}
		.iframeWrapperSmall:after {
			content: "";
			position: absolute;
			z-index: 1;
			left: 0%;
			top: 10%;
			width: 100%;
			height: 80%;
			background-color: #80808000;
		}
		.iframeWrapperBig {
			display: inline-block;
			position: relative;
			vertical-align: top;
		}
		.iframeWrapperBig:after {
			content: "";
			position: absolute;
			z-index: 1;
			left: 0;
			top: 0;
			width: 100%;
			height: 100%;
			background-color: #80808000;
		}
		iframe {
			vertical-align: top;
		}
		#playlist {
			height: 400px;
			overflow-y: scroll;
			list-style-type: none;
			margin-right:5px;
			margin-left:0px;
		}
		#playlistdiv {
			background-image: linear-gradient(rgba(255,255,255,0), rgba(255,255,255,.5))
		}
		hr {
			width: 50%;
		}
		.responseOff {
			font-size: 20px;
			/* Fade out */
			animation: fadeOut ease 2s;
			opacity: 0;
		}
		.responseOn {
			font-size: 20px;
			/* Fade in */
			animation: fadeIn ease 2s;
			opacity: 1;
		}
		@keyframes fadeIn {
			0% {opacity:0;}
			100% {opacity:1;}
		}
		@keyframes fadeOut {
			0% {opacity:1;}
			100% {opacity:0;}
		}
		</style>
	</head>
	<body onload="init()">
		<script>
		var UPDATE_INTERVAL = 1000;
		var MESSAGE_DURATION = 5000;
		var FADE_DURATION = 2000;
		var fadeTimerA = null;
		var fadeTimerB = null;
		
		var tag = document.createElement('script');
		tag.src = "https://www.youtube.com/iframe_api";
		var firstScriptTag = document.getElementsByTagName('script')[0];
		firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
		
		var name = '{% name %}';
		var password = '{% password %}'; // plaintext.
		
		// big iff true
		function setWrapperSize(b) {
			var ifw = document.getElementById('playerdiv');
			ifw.className = (b) ? 'iframeWrapperBig' : 'iframeWrapperSmall';
		}
		
		function setResponseVisible(el, b) {
			el.className = (b) ? 'responseOn' : 'responseOff';
		}
		
		//var lastPlayerState = null;
		var player = null;
		function onYouTubeIframeAPIReady() {
			player = new YT.Player('player', {});
			setWrapperSize(true);
			//player.seekTo(lastTime, true);
			/*
			player.addEventListener('onStateChange', function(state) {
				console.log(state['data'] + ' ... ' + lastPlayerState);
				// This on its own could handle the unpause synchronization, I think, but doesn't quite work yet
				if (state['data'] == 1 && (lastPlayerState == -1 || lastPlayerState == 2)) {
					console.log('Seeking');
					player.seekTo(lastTime, true);
				}
				lastPlayerState = state['data'];
			});
			*/
		}
		
		var paused = false;
		var unpausing = false;
		var muted = 1; // Initially muted because otherwise the video won't autoplay?
		var unmuteApplied = false; // Only unmute at the beginning. Don't unmute every click
		var currentSong = 'https://www.youtube.com/embed/';
		var lastTime = 0;
		var playlistSize = 0;
		var lastActiveIndex = -1;
		var nowPlaying = false;
		
		function init() {
			getPlaylist();
		}
		
		function update() {
			// Replaces upkeep, and also gets extra functionality, without having to make multiple server reqeusts
			var xhttp = new XMLHttpRequest();
			xhttp.onreadystatechange = function() {
				if (this.readyState == 4 && this.status == 200) {
					// Parse the JSON reponse
					//console.log(xhttp.responseText);
					var res = JSON.parse(xhttp.responseText);
					// Update current DJ, DJ list, newcomer list, user list, and playlist index
					document.getElementById('djcurr').innerHTML = res['currentUser'];
					nowPlaying = res['playing'];
					updateDJList(res['queue']);
					updateNewcomerList(res['newcomers']);
					updateUserList(res['userList']);
					updatePlaylistActiveSong(parseInt(res['playlistIndex']));
					// Show the current state of whether the playlist is active
					var toggleEl = document.getElementById('toggleplaylist');
					if (res['usingPlaylist']) {
						toggleEl.innerHTML = 'Deactivate';
					}
					else {
						toggleEl.innerHTML = 'Activate';
					}
					// Update the current song, but only if not paused
					if (!paused) {
						updateSong(res['currentSong'], parseInt(res['time']))
					}
					// Update the time on the song, regardless of whether it is paused
					lastTime = parseInt(res['time']);
					console.log(lastTime);
				}
			};
			xhttp.open('GET', 'update?name='+name+'&password='+password, true);
			xhttp.send();
		}
		
		function updatePlaylistActiveSong(index) {
			if (index != -1) {
				var el = document.getElementById('list'+index);
				if (el != null) {
					if (nowPlaying) {
						el.className = 'playingSong';
					}
					else {
						el.className = 'activeSong';
					}
				}
			}
			if (lastActiveIndex != -1 && index != lastActiveIndex) {
				var el_last = document.getElementById('list'+lastActiveIndex);
				if (el_last != null) {
					el_last.className = 'inactiveSong';
				}
			}
			lastActiveIndex = index;
		}
		
		function togglePause() {
			// Only allow pause toggle when a video is actually active, otherwise the behavior will be weird.
			if (currentSong != 'https://www.youtube.com/embed/') {
				console.log('Toggle pause');
				paused = !paused;
				if (!paused) {
					//getSong();
					//getTime();
					unpausing = true;
					update();
					if (player != null) {
						player.playVideo();
					}
					//unpausing = false; //This is bad, it asynchronously sets it back immediately...
				}
				else {
					if (player != null) {
						player.pauseVideo();
					}
				}
			}
		}
		
		function getPlaylist() {
			var xhttp = new XMLHttpRequest();
			xhttp.onreadystatechange = function() {
				if (this.readyState == 4 && this.status == 200) {
					var res = JSON.parse(xhttp.responseText);
					console.log('Playlist data: ' +xhttp.responseText);
					if (res['data'] != '') {
						lastActiveIndex = res['index'];
						nowPlaying = res['playing'];
						var playlist = res['data'].split('\\');
						playlistSize = playlist.length;
						var playlisttext = '';
						for (var i = 0; i < playlistSize; i++) {
							var tempClassName = 'inactiveSong';
							if (i == lastActiveIndex) {
								tempClassName = 'activeSong';
								if (nowPlaying) {
									tempClassName = 'playingSong';
								}
							}
							playlisttext += '<li><button title="Delete" class="del" id="del'+i+'" onclick="remove('+i+')">X</button><button title="Move to Top" class="toTop" id="toTop'+i+'" onclick="moveToTop('+i+')">&#8607;</button><button title="Move Up" class="up" id="up'+i+'" onclick="moveUp('+i+')">&#8593;</button><button title="Move Down" class="down" id="down'+i+'" onclick="moveDown('+i+')">&#8595;</button><button title="Move to Bottom" class="toBottom" id="toBottom'+i+'" onclick="moveToBottom('+i+')">&#8609;</button><br><span id="list'+i+'" class="'+tempClassName+'">'+playlist[i]+'</span></li><hr>'
						}
						document.getElementById('playlist').innerHTML = playlisttext;
						enableButtons();
					}
					else {
						playlistSize = 0;
						document.getElementById('playlist').innerHTML = '';
					}
				}
			};
			xhttp.open('GET', 'playlist?name='+name+'&password='+password, true);
			xhttp.send();
		}
		
		function updateUserList(listText) {
			var userlist = listText.split('\\');
			//console.log(userlist);
			var userstext = '';
			for (var i = 0; i < userlist.length; i++) {
				userstext += userlist[i];
				if (i != userlist.length-1) {
					userstext += ', ';
				}
			}
			document.getElementById('users').innerHTML = userstext;
		}
		
		function updateDJList(listText) {
			var djlist = listText.split('\\');
			for (var i = 0; i < 10; i++) {
				let v = '';
				if (i < djlist.length) {
					v = djlist[i];
				}
				document.getElementById('dj'+i).innerHTML = v;
			}
		}
		
		function updateNewcomerList(listText) {
			var newcomerlist = listText.split('\\');
			for (var i = 0; i < 3; i++) {
				let v = '';
				if (i < newcomerlist.length) {
					v = newcomerlist[i];
				}
				document.getElementById('new'+i).innerHTML = v;
			}
		}
		
		function updateSong(newSong, newTime) {
			//console.log('Updating song');
			// LastTime thing is for auto-synchronizing, but it may only really be necessary when unpausing.
			// However, it becomes necessary because the same song can play twice in a row, and the time index is the only thing that helps you.
			if (currentSong == 'https://www.youtube.com/embed/' || unpausing || newTime < lastTime) {
				if (newSong != 'https://www.youtube.com/embed/') {
					// TODO: Update this to use the Youtube API better
					if (currentSong == newSong) {
						if (player != null) {
							// Seek to the right time in video (this should be faster than reloading the video)
							player.seekTo(newTime, true);
						}
						else {
							// Fall back on what I know works
							console.log('Falling back, not using API');
							document.getElementById('player').src = currentSong + '?enablejsapi=1&controls=1&autoplay=1&mute='+muted+'&start=' + newTime;
						}
					}
					else {
						console.log('Changing song');
						currentSong = newSong;
						// Change title (this is just the song ID and not the actual title of the song)
						//document.head.title.innerHTML = currentSong;
						// Mute added to align with Google's policies about autoplay
						document.getElementById('player').src = currentSong + '?enablejsapi=1&controls=1&autoplay=1&mute='+muted+'&start=' + newTime;
					}
					setWrapperSize(false);
					unpausing = false; // Has to be set here or it will be asynchronously reset too early!
				}
				else if (currentSong != 'https://www.youtube.com/embed/') {
					// Change title (back, only needed if the title changed...)
					//document.head.title.innerHTML = 'Music Room';
					lastTime = 0;
					currentSong = newSong;
					document.getElementById('player').src = currentSong;
					setWrapperSize(true);
				}
			}
			//lastTime = newTime;
		}
		
		function add() {
			var songId = document.getElementById('tempsongid').value;
			// Clear the textbox
			document.getElementById('tempsongid').value = '';
			console.log(songId);
			var xhttp = new XMLHttpRequest();
			xhttp.onreadystatechange = function() {
				if (this.readyState == 4 && this.status == 200) {
					var el = document.getElementById('responsetemp');
					el.innerHTML = xhttp.responseText;
					//setResponseVisible(el, true);
					//console.log('Visible');
					if (fadeTimerA != null) {
						clearTimeout(fadeTimerA);
					}
					fadeTimerA = setTimeout(function() { setResponseVisible(el, false); }, MESSAGE_DURATION);
					document.getElementById('addbutton').disabled = false;
				}
			};
			xhttp.open('GET', 'add?name='+name+'&password='+password+'&songId='+songId, true);
			xhttp.send();
			document.getElementById('addbutton').disabled = true;
			var el = document.getElementById('responsetemp');
			el.innerHTML = 'Loading...';
			setResponseVisible(el, true);
		}
		
		function listAdd() {
			var songId = document.getElementById('songid').value;
			// Clear the textbox
			document.getElementById('songid').value = '';
			console.log(songId);
			var xhttp = new XMLHttpRequest();
			xhttp.onreadystatechange = function() {
				if (this.readyState == 4 && this.status == 200) {
					var el = document.getElementById('response');
					el.innerHTML = xhttp.responseText;
					//setResponseVisible(el, true);
					//console.log('Visible');
					if (fadeTimerB != null) {
						clearTimeout(fadeTimerB);
					}
					fadeTimerB = setTimeout(function() { setResponseVisible(el, false); }, MESSAGE_DURATION);
					getPlaylist();
					document.getElementById('listaddbutton').disabled = false;
				}
			};
			xhttp.open('GET', 'listadd?name='+name+'&password='+password+'&songId='+songId, true);
			xhttp.send();
			document.getElementById('listaddbutton').disabled = true;
			var el = document.getElementById('response');
			el.innerHTML = 'Loading...';
			setResponseVisible(el, true);
		}
		
		function togglePlaylist() {
			var el = document.getElementById('toggleplaylist');
			if (el.innerHTML == 'Activate') {
				el.innerHTML = 'Activating...';
			}
			else {
				el.innerHTML = 'Deactivating...';
			}
			var xhttp = new XMLHttpRequest();
			xhttp.onreadystatechange = function() {
				if (this.readyState == 4 && this.status == 200) {
					var res = xhttp.responseText;
					if (res == 'Activate' || res == 'Deactivate') {
						el.disabled = false;
					}
					el.innerHTML = res;
				}
			};
			xhttp.open('GET', 'toggle?name='+name+'&password='+password, true);
			xhttp.send();
			el.disabled = true;
		}
		
		// Helps prevent extra rearranging while the server is still processing it
		function disableButtons() {
			for (var i = 0; i < playlistSize; i++) {
				document.getElementById('del'+i).disabled = true;
				document.getElementById('toTop'+i).disabled = true;
				document.getElementById('up'+i).disabled = true;
				document.getElementById('down'+i).disabled = true;
				document.getElementById('toBottom'+i).disabled = true;
			}
		}
		
		function enableButtons() {
			for (var i = 0; i < playlistSize; i++) {
				document.getElementById('del'+i).disabled = false;
				document.getElementById('toTop'+i).disabled = false;
				document.getElementById('up'+i).disabled = false;
				document.getElementById('down'+i).disabled = false;
				document.getElementById('toBottom'+i).disabled = false;
			}
		}
		
		function remove(i) {
			console.log('Deleting song '+i);
			disableButtons();
			var xhttp = new XMLHttpRequest();
			xhttp.onreadystatechange = function() {
				if (this.readyState == 4 && this.status == 200) {
					// Get updated playlist (don't deal with trying to rearrange the indices yourself.)
					getPlaylist();
				}
			};
			xhttp.open('GET', 'remove?name='+name+'&password='+password+'&idx='+i, true);
			xhttp.send();
		}
		
		function moveUp(i) {
			if (i != 0) {
				disableButtons();
				var xhttp = new XMLHttpRequest();
				xhttp.onreadystatechange = function() {
					if (this.readyState == 4 && this.status == 200) {
						// Get updated playlist (don't deal with trying to rearrange the indices yourself.)
						getPlaylist();
					}
				};
				xhttp.open('GET', 'move?name='+name+'&password='+password+'&i='+i+'&j='+(i-1), true);
				xhttp.send();
			}
		}
		
		function moveDown(i) {
			if (i != playlistSize-1) {
				disableButtons();
				var xhttp = new XMLHttpRequest();
				xhttp.onreadystatechange = function() {
					if (this.readyState == 4 && this.status == 200) {
						// Get updated playlist (don't deal with trying to rearrange the indices yourself.)
						getPlaylist();
					}
				};
				xhttp.open('GET', 'move?name='+name+'&password='+password+'&i='+i+'&j='+(i+1), true);
				xhttp.send();
			}
		}
		
		function moveToTop(i) {
			if (i != 0) {
				disableButtons();
				var xhttp = new XMLHttpRequest();
				xhttp.onreadystatechange = function() {
					if (this.readyState == 4 && this.status == 200) {
						// Get updated playlist (don't deal with trying to rearrange the indices yourself.)
						getPlaylist();
					}
				};
				xhttp.open('GET', 'move?name='+name+'&password='+password+'&i='+i+'&j=0', true);
				xhttp.send();
			}
		}
		
		function moveToBottom(i) {
			if (i != playlistSize-1) {
				disableButtons();
				var xhttp = new XMLHttpRequest();
				xhttp.onreadystatechange = function() {
					if (this.readyState == 4 && this.status == 200) {
						// Get updated playlist (don't deal with trying to rearrange the indices yourself.)
						getPlaylist();
					}
				};
				xhttp.open('GET', 'move?name='+name+'&password='+password+'&i='+i+'&j='+(playlistSize-1), true);
				xhttp.send();
			}
		}
		
		function voteSkip() {
			var reason = prompt("Are you sure you want to skip?", "Reason for skipping (optional, for debug)");
			if (reason != null) {
				console.log('Voting to skip');
				var xhttp = new XMLHttpRequest();
				xhttp.onreadystatechange = function() {
					if (this.readyState == 4 && this.status == 200) {
						// Nothing to do I guess
					}
				};
				if (reason != '') {
					xhttp.open('GET', 'skip?name='+name+'&password='+password+'&reason='+reason, true);
				}
				else {
					xhttp.open('GET', 'skip?name='+name+'&password='+password+'&reason=null', true);
				}
				xhttp.send();
			}
			else {
				console.log('Cancelled skip');
			}
		}
		
		function savePlaylist() {
			if (playlistSize > 0) {
				var xhttp = new XMLHttpRequest();
				xhttp.onreadystatechange = function() {
					if (this.readyState == 4 && this.status == 200) {
						//Download a txt file
						if (xhttp.responseText != '') {
							var data = new Blob([xhttp.responseText], {type: 'text/plain'});
							var url = window.URL.createObjectURL(data);
							window.open(url, '_blank');
						}
					}
				};
				xhttp.open('GET', 'save?name='+name+'&password='+password, true);
				xhttp.send();
			}
			
		}
		
		document.addEventListener('click', function() {
			muted = 0;
			// I was hoping this would work on mobile, but it does not.
			if (player != null && !unmuteApplied && currentSong != 'https://www.youtube.com/embed/') {
				player.unMute();
				console.log('unmuted');
				unmuteApplied = true;
			}
		});
		
		(function() {
			var hidden = "hidden";
			
			// Standards:
			if (hidden in document)
				document.addEventListener("visibilitychange", onchange);
			else if ((hidden = "mozHidden") in document)
				document.addEventListener("mozvisibilitychange", onchange);
			else if ((hidden = "webkitHidden") in document)
				document.addEventListener("webkitvisibilitychange", onchange);
			else if ((hidden = "msHidden") in document)
				document.addEventListener("msvisibilitychange", onchange);
			// IE 9 and lower:
			else if ("onfocusin" in document)
				document.onfocusin = document.onfocusout = onchange;
			// All others:
			else
				window.onpageshow = window.onpagehide = window.onfocus = window.onblur = onchange;
			
			function onchange (evt) {
				var v = "visible", h = "hidden",
				evtMap = {
				  focus:v, focusin:v, pageshow:v, blur:h, focusout:h, pagehide:h
				};
				evt = evt || window.event;
				if (evt.type in evtMap) {
					document.body.className = evtMap[evt.type];
				}
				else {
					document.body.className = this[hidden] ? "hidden" : "visible";
				}
				if (document.body.className != "hidden") {
					console.log('Update after coming back from another tab');
					unpausing = true; //Reusing this.
					update();
				}
			}
			
			// set the initial state (but only if browser supports the Page Visibility API)
			if( document[hidden] !== undefined )
				onchange({type: document[hidden] ? "blur" : "focus"});
		})();
		
		setInterval(update, UPDATE_INTERVAL);
		
		</script>
		<table class="maintable">
			<tr>
				<td colspan="3">
					<h1>Music Room</h1>
				</td>
			</tr>
			<tr>
				<td id="queuebox" width="25%">
					<h3>Current DJ: <span id="djcurr">None</span></h3>
					<h4 style="text-align: left;">Next up:</h4>
					<ol>
						<li id="dj0"></li>
						<li id="dj1"></li>
						<li id="dj2"></li>
						<li id="dj3"></li>
						<li id="dj4"></li>
						<li id="dj5"></li>
						<li id="dj6"></li>
						<li id="dj7"></li>
						<li id="dj8"></li>
						<li id="dj9"></li>
					</ol>
					<br>
					<h4 style="text-align: left;">Newcomers:</h4>
					<ol>
						<li id="new0"></li>
						<li id="new1"></li>
						<li id="new2"></li>
					</ol>
					<h4>Temporary Song</h4>
					<p>Enter a URL to add a temporary song:</p>
					<input id="tempsongid" type="text" name="tempsongid" maxlength="50">
					<button id="addbutton" onclick="add()">Submit</button>
					<p class="responseOff" id="responsetemp">&nbsp;</p>
					<button onclick="voteSkip()">Vote to Skip</button>
				</td>
				<td id="videobox" width="50%">
					<div id="playerdiv" class="iframeWrapperBig" onclick="togglePause()">
						<iframe id="player" width="800px" height="600px" src="https://www.youtube.com/embed/" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
					</div>
				</td>
				<td id="playlistbox" width="25%">
					<h3>Playlist</h3>
					<div id="playlistdiv">
						<ol id="playlist">
						</ol>
					</div>
					<button id="toggleplaylist" onclick="togglePlaylist()">Activate</button>
					<br>
					<h4>Add to Playlist</h4>
					<!--<p>Enter an ID to add to your list:</p>-->
					<input id="songid" type="text" name="songid" maxlength="1199">
					<button id="listaddbutton" onclick="listAdd()">Submit</button>
					<p class="responseOff" id="response">&nbsp;</p>
					<button onclick="savePlaylist()">Save Playlist</button><!--<button onclick="loadPlaylist()">Load Playlist</button>-->
				</td>
			</tr>
			<tr>
				<td colspan="3">
                    <p><b>Users:</b> <span id="users"></span></p>
				</td>
			</tr>
		</table>
		<h5>Bugs</h5>
		<ul>
			<li>Temporary songs only allow you to play one song, so if you a second temporary song before your temporary song plays, the new one will overwrite it</li>
			<li>Title of video does not show on mobile</li>
			<li>Subtitles/annotations/quality/more videos can only be accessed in fullscreen mode</li>
			<li>Clicking the unpause button in the corner will not resume to live timing, only clicking the middle of the video will</li>
			<li>Mobile version now seems to work, but requires clicking the video twice at the start</li>
			<li>Mobile version characters for playlist rearrangements oddly sized compared to desktop version</li>
			<li>Next up undefined can happen, at which point everything is broken I guess (maybe fixed?)</li>

			<li>Playlist could be formatted better</li>
			<li>Tabbing over will re-seek the video, causing a bit of a blip if already playing</li>
			<li>Newest person is not added to the user queue order in the correct position, but rather just at the end</li>
		</ul>
	</body>
</html>